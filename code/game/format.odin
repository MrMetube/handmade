#+vet !unused-procedures
package game

@(common="file")

import "core:time"

import "base:intrinsics"
import "base:runtime"
import "core:os"

// @volatile This breaks if in the midst of a print we start another print on the same thread
ConsoleBufferSize :: #config(ConsoleBufferSize, 128 * Megabyte)
@(thread_local) console_buffer: [ConsoleBufferSize]u8

/* 
A list of currently-supported views are below:

 - `raw(expr)`: Ignores all views used in `expr`, including those automatically applied by type views.
 - `no_addr(expr)`: Disables explicit address visualization with pointer evaluations in `expr`.

 - `sequence(expr)`: Interprets `expr` as an integer, encoding how many sub-expressions `expr` should expand to produce. This can be used in combination with the `table` view to easily generate tables, indexing amongst many arrays.
 - `rows(expr, ...)`: Interpreting all post-`expr` arguments as member names, only expands to show those members of `expr`.
 - `omit(expr, ...)`: Interpreting all post-`expr` arguments as member names, expands to show all members of `expr`, except those with matching names.
 - `table/columns(expr, ...)`: Expresses that `expr` should be expanded normally, but interprets all post-`expr` arguments as expressions which should be used to form cells for rows which are generated by this expression's expansions. This replaces the normal cells which are generated for an expansion in a Watch table.
*/

print :: proc { format_string, print_to_console }

@(printlike)
print_to_console :: proc (format: string, args: ..any, flags: FormatContextFlags = {}) {
    result := print(buffer = console_buffer[:], format = format, args = args, flags = flags)
    os.write(os.stdout, transmute([]u8) result)
}
@(printlike)
println :: proc(format: string, args: ..any, flags: FormatContextFlags = {}) {
    print_to_console(format = format, args = args, flags = flags + { .AppendNewlineToResult })
}

/* @todo(viktor): 
    - rename default float to shortest because ryu
        - make ryu able to print fixed precision f32s
    - thousands dividers,
    - Add some Docs and Usage
*/

////////////////////////////////////////////////

ViewKind :: enum u8 {
    Bytes,
    
    String, Character, 
    
    UnsignedInteger, SignedInteger,
    Float,
    
    Indent, Outdent, Linebreak,
}

View :: struct {
    value: struct #raw_union {
        byte:  u8,
        word:  u16,
        dword: u32,
        qword: u64,
        
        half_float:   f16,
        single_float: f32,
        double_float: f64,
        
        bytes: []u8,
    },
    size: u8,
    kind: ViewKind,
    
    sets: bit_set[ enum {Width, Basis, Precision}],
    // General
    width:          u16,
    pad_right_side: b8,
    // @todo(viktor): string format, escaped, (as hex)
    
    // @todo(viktor): thousands divider (and which scale to use, see indian scale), 
    // ^ is this a userspace function?
    
    // @todo(viktor): copy over flags from context and let a format element override the context for its data
    
    // Numbers
    flags:         FormatNumberFlags,
    positive_sign: FormatNumberSign,
    
    // Integer
    basis: u8,
    
    // Float
    precision:  u8,
    float_kind: FormatFloatKind,
}

FormatNumberSign   :: enum u8 { Never, Plus, Space }
FormatFloatKind    :: enum u8 { Default, MaximumPercision, Scientific }
FormatNumberFlags  :: bit_set[ enum u8 { 
    LeadingZero, PrependBaseSpecifier, Uppercase,
}; u8 ]
FormatContextFlags :: bit_set[ enum u8 {
    PrependTypes, Multiline, AppendNewlineToResult,
}; u8 ]

////////////////////////////////////////////////

// @todo(viktor): this could also take an enum which is then interpreted as a float
// @todo(viktor): this could also take complex numbers and quaternions
view_float :: proc (
    value: $F, 
    width: Maybe(u16) = nil, pad_right_side: b8 = false,
    flags: FormatNumberFlags = {}, positive_sign: FormatNumberSign = .Never, 
    precision: Maybe(u8) = nil, kind: FormatFloatKind = .Default
) -> (result: View) 
where intrinsics.type_is_float(F) {
         when F == f16 do result.value.half_float   = value
    else when F == f32 do result.value.single_float = value
    else when F == f64 do result.value.double_float = value
    else do #panic("not a supported float")
    
    result.kind  = .Float
    result.size = size_of(value)
    
    view_set_general(&result, width, pad_right_side)
    view_set_number(&result, flags, positive_sign)
    view_set_precision(&result, precision)
    
    result.float_kind = kind
    
    return result
}

view_integer :: proc (
    value: $I, 
    width: Maybe(u16) = nil, pad_right_side: b8 = false,
    flags: FormatNumberFlags = {}, positive_sign: FormatNumberSign = .Never, 
    basis: Maybe(u8) = nil,
) -> (result: View) 
where intrinsics.type_is_integer(I) {
    result.size = size_of(value)
    
           when I == u8  { result.kind = .UnsignedInteger; result.value.byte = value
    } else when I == u16 { result.kind = .UnsignedInteger; result.value.word = value
    } else when I == u32 { result.kind = .UnsignedInteger; result.value.dword = value
    } else when I == u64 { result.kind = .UnsignedInteger; result.value.qword = value
    } else when I == i8  { result.kind = .SignedInteger; result.value.byte  = transmute(u8) value
    } else when I == i16 { result.kind = .SignedInteger; result.value.word  = transmute(u16) value
    } else when I == i32 { result.kind = .SignedInteger; result.value.dword = transmute(u32) value
    } else when I == i64 { result.kind = .SignedInteger; result.value.qword = transmute(u64) value
    
    } else when I == int     && size_of(int)     == 4 { result.kind = .SignedInteger;   result.value.dword = transmute(u32) value
    } else when I == int     && size_of(int)     == 8 { result.kind = .SignedInteger;   result.value.qword = transmute(u64) value
    } else when I == uint    && size_of(uint)    == 4 { result.kind = .UnsignedInteger; result.value.dword = transmute(u32) value
    } else when I == uint    && size_of(uint)    == 8 { result.kind = .UnsignedInteger; result.value.qword = transmute(u64) value
    } else when I == uintptr && size_of(uintptr) == 4 { result.kind = .UnsignedInteger; result.value.dword = transmute(u32) value
    } else when I == uintptr && size_of(uintptr) == 8 { result.kind = .UnsignedInteger; result.value.qword = transmute(u64) value
    } else {
        core := runtime.type_info_core(type_info_of(I))
        switch core.id {
          case u8:  result = view_integer(cast(u8)  value, width, pad_right_side, flags, positive_sign, basis)
          case u16: result = view_integer(cast(u16) value, width, pad_right_side, flags, positive_sign, basis)
          case u32: result = view_integer(cast(u32) value, width, pad_right_side, flags, positive_sign, basis)
          case u64: result = view_integer(cast(u64) value, width, pad_right_side, flags, positive_sign, basis)
          case i8:  result = view_integer(cast(i8)  value, width, pad_right_side, flags, positive_sign, basis)
          case i16: result = view_integer(cast(i16) value, width, pad_right_side, flags, positive_sign, basis)
          case i32: result = view_integer(cast(i32) value, width, pad_right_side, flags, positive_sign, basis)
          case i64: result = view_integer(cast(i64) value, width, pad_right_side, flags, positive_sign, basis)
          case: unreachable()
        }
        return result
    }
    
    view_set_general(&result, width, pad_right_side)
    view_set_number(&result, flags, positive_sign)
    
    if basis, ok := basis.?; ok {
        result.sets += { .Basis }
        result.basis = basis
    }
    
    return result
}

view_bin :: proc (
    value: $I, 
    width: Maybe(u16) = nil, pad_right_side: b8 = false,
    flags: FormatNumberFlags = {}, positive_sign: FormatNumberSign = .Never, 
) -> (result: View) {
    result = view_integer(value, width, pad_right_side, flags + { .PrependBaseSpecifier }, positive_sign, basis = 2)
    return result
}

view_oct :: proc (
    value: $I, 
    width: Maybe(u16) = nil, pad_right_side: b8 = false,
    flags: FormatNumberFlags = {}, positive_sign: FormatNumberSign = .Never, 
) -> (result: View) {
    result = view_integer(value, width, pad_right_side, flags + { .PrependBaseSpecifier }, positive_sign, basis = 8)
    return result
}

view_dec :: proc (
    value: $I, 
    width: Maybe(u16) = nil, pad_right_side: b8 = false,
    flags: FormatNumberFlags = {}, positive_sign: FormatNumberSign = .Never, 
) -> (result: View) {
    result = view_integer(value, width, pad_right_side, flags + { .PrependBaseSpecifier }, positive_sign, basis = 10)
    return result
}

view_hex :: proc (
    value: $I, 
    width: Maybe(u16) = nil, pad_right_side: b8 = false,
    flags: FormatNumberFlags = {}, positive_sign: FormatNumberSign = .Never, 
) -> (result: View) {
    result = view_integer(value, width, pad_right_side, flags + { .PrependBaseSpecifier }, positive_sign, basis = 16)
    return result
}

////////////////////////////////////////////////

view_character :: proc(value: u8) -> (result: View) {
    result = {
        kind  = .Character,
        value = { byte = value },
    }
    return result
}

// @todo(viktor): string view options
view_string :: proc(value: string) -> (result: View) {
    result = {
        kind  = .String, 
        value = { bytes = transmute([]u8) value }
    }
    return result
}

////////////////////////////////////////////////


view_raw :: proc (value: $T) -> (result: View) {}
view_no_addr :: proc (value: $T) {}

view_variable :: proc(value: $T, op := "=", expression := #caller_expression(value)) -> (string, string, T) {
    return expression, op, value
}

view_sequence :: proc (value: $T) {}

view_rows :: proc (value: $T) {}
view_omit :: proc (value: $T) {}

view_array :: proc (value: ^$T, count: $N) -> (result: []T) {
    return (cast([^]T) value)[:count]
}

view_table :: view_columns
view_columns :: proc (value: $T) {}

// view_range1 :: proc (value: $T) {}
// view_text   :: proc (value: $T) {}
// view_disasm :: proc (value: $T) {}
// view_memory :: proc (value: $T) {}
// view_bitmap :: proc (value: $T) {}
// view_color  :: proc (value: $T) {}

////////////////////////////////////////////////

view_set_data :: proc(view: ^View, value: $T, kind: ViewKind) {
    view.data = value
    view.kind = kind
}

view_set_number :: proc (view: ^View, flags: FormatNumberFlags = {}, positive_sign: FormatNumberSign = .Never,) {
    view.flags = flags
    view.positive_sign = positive_sign
}

view_set_general :: proc (view: ^View, width: Maybe(u16) = nil, pad_right_side: b8 = false) {
    if width, ok := width.?; ok {
        view.sets += { .Width }
        view.width = width
    }
    view.pad_right_side = pad_right_side
}

view_set_precision :: proc (view: ^View, precision: Maybe(u8) = nil) {
    if precision, ok := precision.?; ok {
        view.sets += { .Precision }
        view.precision = precision
    }
}

////////////////////////////////////////////////

FormatContext :: struct {
    dest:  StringBuilder,
    
    max_depth: u32,
    indentation: string,
    indentation_depth: u32,
    flags: FormatContextFlags,
}

////////////////////////////////////////////////

/* 
_print 
  1M
formatstring 
  4.6M base
  800k dont clear temp
  1.1M reenable odins floats
  1M compact View 84 -> 32 bytes
  750k bad floats
*/
@(private="file")
temp_buffer:  [1024]u8

begin_formatting :: proc (buffer: []u8, flags: FormatContextFlags) -> (result: FormatContext) {
    result = { 
        dest  = { data = buffer },
        flags = flags,
        
        indentation = "  ",
        max_depth = 8,
    }
    
    return result
}

end_formatting :: proc (ctx: ^FormatContext) -> (result: string) {
    /* @todo(viktor): 
        StringFormat DoubleQuoted_Escaped,
    */
    
    return to_string(ctx.dest)
}

@(printlike)
format_string :: proc (buffer: []u8, format: string, args: ..any, flags := FormatContextFlags{}) -> (result: string) {
    ctx := begin_formatting(buffer, flags)
    
    { 
        start_of_text: int
        arg_index: u32
        // :PrintlikeChecking @volatile the loop structure is copied in the metaprogram to check the arg count, any changes here
        // need to be propagated to there
        for index: int; index < len(format); index += 1 {
            if format[index] == '%' {
                part := format[start_of_text:index]
                if part != "" {
                    format_view(&ctx, view_string(part))
                }
                start_of_text = index+1
                
                if index+1 < len(format) && format[index+1] == '%' {
                    index += 1
                    // @note(viktor): start_of_text now points at the percent sign and will append it next time saving processing one view
                } else {
                    arg := args[arg_index]
                    arg_index += 1
                    
                    // @todo(viktor): Would be ever want to display a raw View? if so put in a flag to make it use the normal path
                    switch format in arg {
                    case View: format_view(&ctx, format)
                    case:      format_any(&ctx, arg)
                    }
                }
            }
        }
        end := format[start_of_text:]
        if end != "" {
            format_view(&ctx, view_string(end))
        }
        
        assert(arg_index == auto_cast len(args))
        
        if .AppendNewlineToResult in flags {
            format_view(&ctx, view_character('\n'))
        }
    }
    
    return end_formatting(&ctx)
}

format_view :: proc (ctx: ^FormatContext, view: View) {
    view := view
    temp := StringBuilder { data = temp_buffer[:] }
            
    switch view.kind {
      case .Indent:
        assert(.Multiline in ctx.flags)
        ctx.indentation_depth += 1
        
      case .Outdent:
        assert(.Multiline in ctx.flags)
        ctx.indentation_depth -= 1
        
      case .Linebreak:
        assert(.Multiline in ctx.flags)
        append(&ctx.dest, "\n")
        for _ in 0..<ctx.indentation_depth do append(&ctx.dest, ctx.indentation)
        
        
      case .Bytes:
        unimplemented()
        
      case .String:    append(&temp, view.value.bytes)
      case .Character: append(&temp, view.value.byte)
        
      case .UnsignedInteger:
        value: u64 = ---
        switch view.size {
          case 1: value = cast(u64) view.value.byte
          case 2: value = cast(u64) view.value.word
          case 4: value = cast(u64) view.value.dword
          case 8: value =           view.value.qword
          case: unreachable()
        }
        format_unsigned_integer(&temp, value, &view)
        
      case .SignedInteger:
        value: i64 = ---
        switch view.size {
          case 1: value = cast(i64) (cast(^i8)  &view.value.byte)^
          case 2: value = cast(i64) (cast(^i16) &view.value.word)^
          case 4: value = cast(i64) (cast(^i32) &view.value.dword)^
          case 8: value =           (cast(^i64) &view.value.qword)^
          case: unreachable()
        }
        format_signed_integer(&temp, value, &view)
        
      case .Float:
        // @todo(viktor): endianess relevant?
        // This is wrong when we use the format_integer subroutine view.flags += {.LeadingZero}
        switch view.size {
          case 2: format_float_with_ryu(&temp, view.value.half_float,   &view)
          case 4: format_float_with_ryu(&temp, view.value.single_float, &view)
          case 8: format_float_with_ryu(&temp, view.value.double_float, &view)
          case: unreachable()
        }
        // @todo(viktor): 
        // NaN Inf+- 
        // base specifier
        // scientific and max precision
        // as hexadecimal 0h
    }
    
    pad :: proc(dest: ^StringBuilder, count: i32, char: u8 = ' ') {
        for _ in 0..<count {
            append(dest, char)
        }
    }
    
    padding := max(0, cast(i32) view.width - cast(i32) temp.count)
    if       !view.pad_right_side && .Width in view.sets do pad(&ctx.dest, padding)
    defer if  view.pad_right_side && .Width in view.sets do pad(&ctx.dest, padding)
    
    append(&ctx.dest, to_string(temp))
}

////////////////////////////////////////////////

format_any :: proc(ctx: ^FormatContext, arg: any) {
    if ctx.max_depth <= 0 do return
    
    switch value in arg {
      case string:  format_view(ctx, view_string(value))
      case cstring: format_view(ctx, view_string(string(value)))
        
      case b8:   format_boolean(ctx, cast(b32) value)
      case b16:  format_boolean(ctx, cast(b32) value)
      case b32:  format_boolean(ctx,           value)
      case b64:  format_boolean(ctx, cast(b32) value)
      case bool: format_boolean(ctx, cast(b32) value)
      
      case f16:  format_view(ctx, view_float(value))
      case f32:  format_view(ctx, view_float(value))
      case f64:  format_view(ctx, view_float(value))
      
      // @todo(viktor): rune
      case u8:      format_view(ctx, view_integer(value))
      case u16:     format_view(ctx, view_integer(value))
      case u32:     format_view(ctx, view_integer(value))
      case u64:     format_view(ctx, view_integer(value))
      case uint:    format_view(ctx, view_integer(value))
      case uintptr: format_view(ctx, view_integer(value))
        
      case i8:  format_view(ctx, view_integer(value))
      case i16: format_view(ctx, view_integer(value))
      case i32: format_view(ctx, view_integer(value))
      case i64: format_view(ctx, view_integer(value))
      case int: format_view(ctx, view_integer(value))
        
      case any:    format_any(ctx, value)
      case nil:    format_pointer(ctx, nil)
      case rawptr: format_pointer(ctx, value)
        
      case:
        raw := transmute(RawAny) value
        type_info := type_info_of(raw.id)
        
        switch variant in type_info.variant {
          case runtime.Type_Info_Any,
               runtime.Type_Info_Boolean, 
               runtime.Type_Info_Integer, 
               runtime.Type_Info_String,
               runtime.Type_Info_Float:
            unreachable()
            
          case runtime.Type_Info_Pointer:
            data := (cast(^pmm) raw.data)^
            format_pointer(ctx, data, variant.elem)
          case runtime.Type_Info_Multi_Pointer:
            data := (cast(^pmm) raw.data)^
            format_optional_type(ctx, raw.id)
            format_pointer(ctx, data, variant.elem)
          
          
          case runtime.Type_Info_Named:
            // @important @todo(viktor): If the struct is an alias like v4 :: [4]f32 we currently print both types. but we should only print the alias
            // @todo(viktor): Time Duration and SourceCodeLocation should not need to be inlined. find a way for the user to hook into this process and specify custom formats like these
            if dur, okd := value.(time.Duration); okd {
                ffrac :: proc(buf: []byte, v: u64, precision: int) -> (nw: int, nv: u64) {
                    v := v
                    w := len(buf)
                    print := false
                    for _ in 0..<precision {
                        digit := v % 10
                        print = print || digit != 0
                        if print {
                            w -= 1
                            buf[w] = byte(digit) + '0'
                        }
                        v /= 10
                    }
                    if print {
                        w -= 1
                        buf[w] = '.'
                    }
                    return w, v
                }
                fint :: proc(buf: []byte, v: u64) -> int {
                    v := v
                    w := len(buf)
                    if v == 0 {
                        w -= 1
                        buf[w] = '0'
                    } else {
                        for v > 0 {
                            w -= 1
                            buf[w] = byte(v%10) + '0'
                            v /= 10
                        }
                    }
                    return w
                }
                
                buf: [32]byte
                w := len(buf)
                u := u64(dur)
                neg := dur < 0
                if neg {
                    u = -u
                }
                
                if u < u64(time.Second) {
                    precision: int
                    w -= 1
                    buf[w] = 's'
                    w -= 1
                    switch {
                      case u == 0:
                        format_view(ctx, view_string("0s"))
                        return
                      case u < u64(time.Microsecond):
                        precision = 0
                        buf[w] = 'n'
                      case u < u64(time.Millisecond):
                        precision = 3
                        // U+00B5 'µ' micro sign == 0xC2 0xB5
                        w -= 1 // Need room for two bytes
                        copy(buf[w:], "µ")
                      case:
                        precision = 6
                        buf[w] = 'm'
                    }
                    w, u = ffrac(buf[:w], u, precision)
                    w = fint(buf[:w], u)
                } else {
                    w -= 1
                    buf[w] = 's'
                    w, u = ffrac(buf[:w], u, 9)
                    w = fint(buf[:w], u%60)
                    u /= 60
                    if u > 0 {
                        w -= 1
                        buf[w] = 'm'
                        w = fint(buf[:w], u%60)
                        u /= 60
                        if u > 0 {
                            w -= 1
                            buf[w] = 'h'
                            w = fint(buf[:w], u)
                        }
                    }
                }
                
                if neg {
                    w -= 1
                    buf[w] = '-'
                }
                
                format_view(ctx, view_string(string(buf[w:])))
            } else if tim, okt := value.(time.Time); okt {
                t := tim
                y, mon, d := time.date(t)
                h, min, s := time.clock(t)
                ns := (t._nsec - (t._nsec/1e9 + time.UNIX_TO_ABSOLUTE)*1e9) % 1e9
                format_view(ctx, view_integer(cast(i64) y,   width = 4))
                format_view(ctx, view_character('-'))
                format_view(ctx, view_integer(cast(i64) mon, width = 2))
                format_view(ctx, view_character('-'))
                format_view(ctx, view_integer(cast(i64) d,   width = 2))
                format_view(ctx, view_character(' '))

                format_view(ctx, view_integer(cast(i64) h,   width = 2))
                format_view(ctx, view_character(':'))
                format_view(ctx, view_integer(cast(i64) min, width = 2))
                format_view(ctx, view_character(':'))
                format_view(ctx, view_integer(cast(i64) s,   width = 2))
                format_view(ctx, view_character('.'))
                format_view(ctx, view_integer((ns),          width = 9))
                format_view(ctx, view_string(" +0000 UTC"))
            } else if loc, okl := value.(runtime.Source_Code_Location); okl {
                format_view(ctx, view_string(loc.file_path))
            
                when ODIN_ERROR_POS_STYLE == .Default {
                    open  :: '(' 
                    close :: ')'
                } else when ODIN_ERROR_POS_STYLE == .Unix {
                    open  :: ':' 
                    close :: ':'
                } else {
                    #panic("Unhandled ODIN_ERROR_POS_STYLE")
                }
                
                format_view(ctx, view_character(open))
                defer format_view(ctx, view_character(close))
                
                format_view(ctx, view_integer(u64(loc.line)))
                if loc.column != 0 {
                    format_view(ctx, view_character(':'))
                    format_view(ctx, view_integer(u64(loc.column)))
                }
                
            } else {
                format_view(ctx, view_string(variant.name))
                format_view(ctx, view_character(' '))
                format_any(ctx, any{data = raw.data, id = variant.base.id})
            }
            
          case runtime.Type_Info_Struct:
            format_struct(ctx, raw, variant)
            
          case runtime.Type_Info_Union:
            format_union(ctx, raw.id, raw.data, variant)
            
          case runtime.Type_Info_Dynamic_Array:
            slice := cast(^RawSlice) raw.data
            raw_slice := RawAny{slice.data, raw.id}
            format_array(ctx, raw_slice, variant.elem, slice.len)
            
          case runtime.Type_Info_Slice:
            slice := cast(^RawSlice) raw.data
            raw_slice := RawAny{slice.data, raw.id}
            format_array(ctx, raw_slice, variant.elem, slice.len)
            
          case runtime.Type_Info_Array:
            format_array(ctx, raw, variant.elem, variant.count)
            
          case runtime.Type_Info_Map:
            unimplemented("Unimplemented: maps")
            
          case runtime.Type_Info_Complex:
            format_complex(ctx, value)
            format_complex :: proc (ctx: ^FormatContext, value: $C) {
                
            }
            format_optional_type(ctx, raw.id)
            switch complex in value {
              case complex32: 
                format_view(ctx, view_float(real(complex)))
                format_view(ctx, view_float(imag(complex), positive_sign = .Plus))
                format_view(ctx, view_character('i')) 
              case complex64: 
                format_view(ctx, view_float(real(complex)))
                format_view(ctx, view_float(imag(complex), positive_sign = .Plus))
                format_view(ctx, view_character('i')) 
              case complex128:
                format_view(ctx, view_float(real(complex)))
                format_view(ctx, view_float(imag(complex), positive_sign = .Plus))
                format_view(ctx, view_character('i')) 
            }
            
          case runtime.Type_Info_Quaternion:
            format_optional_type(ctx, raw.id)
            switch quaternion in value {
                case quaternion64: 
                  format_view(ctx, view_float(real(quaternion)))
                  format_view(ctx, view_float(imag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('i')) 
                  format_view(ctx, view_float(jmag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('j')) 
                  format_view(ctx, view_float(kmag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('k')) 
                case quaternion128: 
                  format_view(ctx, view_float(real(quaternion)))
                  format_view(ctx, view_float(imag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('i')) 
                  format_view(ctx, view_float(jmag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('j')) 
                  format_view(ctx, view_float(kmag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('k')) 
                case quaternion256:
                  format_view(ctx, view_float(real(quaternion)))
                  format_view(ctx, view_float(imag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('i')) 
                  format_view(ctx, view_float(jmag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('j')) 
                  format_view(ctx, view_float(kmag(quaternion), positive_sign = .Plus))
                  format_view(ctx, view_character('k')) 
              }
              
            
          case runtime.Type_Info_Matrix:
            format_matrix(ctx, raw.id, raw.data, variant.elem, variant.column_count, variant.row_count, variant.layout == .Row_Major)

          case runtime.Type_Info_Rune:
            unimplemented("Unimplemented: rune")
            
          case runtime.Type_Info_Enum:
            // unimplemented("Unimplemented: enums")
          /* 
            . enumerated array   [key0 = elem0, key1 = elem1, key2 = elem2, ...]
            . maps:              map[key0 = value0, key1 = value1, ...]
            . bit sets           {key0 = elem0, key1 = elem1, ...}
           */  
          case runtime.Type_Info_Enumerated_Array:
          case runtime.Type_Info_Bit_Set:
          case runtime.Type_Info_Bit_Field:
            
          case runtime.Type_Info_Parameters:
          case runtime.Type_Info_Procedure:
          case runtime.Type_Info_Simd_Vector:
          case runtime.Type_Info_Soa_Pointer:
          
          case runtime.Type_Info_Type_Id:
            format_type(ctx, type_info)
            
          case: 
            println("%", variant)
            unimplemented("This value is not handled yet")
        }
    }
}

////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////

format_multiline_formatting :: proc(ctx: ^FormatContext, kind: ViewKind) {
    if ctx.max_depth <= 0 do return
    
    if .Multiline in ctx.flags {
        format_view(ctx, View { kind = kind })
    }
}

format_optional_type :: proc(ctx: ^FormatContext, type: typeid) {
    if ctx.max_depth <= 0 do return
    
    if .PrependTypes in ctx.flags {
        format_type(ctx, type_info_of(type))
        format_view(ctx, view_character(' ') )
    }
}

////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////

DigitsLowercase := "0123456789abcdefghijklmnopqrstuvwxyz"
DigitsUppercase := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

format_float_with_ryu :: proc(dest: ^StringBuilder, float: $F, view: ^View) {
    precision: u32 = 6
    if .Precision in view.sets do precision = cast(u32) view.precision
    
    
    // @todo(viktor): handle .Uppercase in view.flags
        
    buffer := rest(dest^)
    when size_of(F) == 8 {
        result := d2fixed_buffered(float, precision, buffer)
        dest.count += auto_cast len(result)
    } else when size_of(F) == 4 {
        result := f2s_buffered(float, buffer)
        dest.count += auto_cast len(result)
    } else when size_of(F) == 2 {
        unimplemented()
    } else do #panic("convert the general algorithm from ryu you laze bum")
}

format_float_badly :: proc(dest: ^StringBuilder, float: $F, view: ^View) {
    fraction, integer := fractional(float)
    
    format_signed_integer(dest, cast(i64) integer, view)
    
    precision: u8 = 6
    if .Precision in view.sets do precision = view.precision
    
    if fraction != 0 && precision != 0 {
        append(dest, '.')
        
        digits := .Uppercase in view.flags ? DigitsUppercase : DigitsLowercase
        
        val: i32
        for _ in 0..<precision {
            fraction, val = fractional(fraction * 10)
            if val >= 0 && val < auto_cast len(digits) {
                append(dest, digits[val])
            } else { /* ??? */ }
        }
    }
}

format_signed_integer :: proc(dest: ^StringBuilder, integer: i64, view: ^View) {
    if integer < 0 {
        append(dest, '-')
    } else if view.positive_sign == .Plus {
        append(dest, '+')
    } else if view.positive_sign == .Space {
        append(dest, ' ')
    } else {
        // @note(viktor): nothing
    }
    
    format_unsigned_integer(dest, cast(u64) abs(integer), view)
}

format_unsigned_integer :: proc(dest: ^StringBuilder, integer: u64, view: ^View) {
    digits := .Uppercase in view.flags ? DigitsUppercase : DigitsLowercase
    
    basis: u64 = 10
    if .Basis in view.sets do basis = cast(u64) view.basis
    assert(view.basis < auto_cast len(digits))
    
    integer := integer
    
    if .PrependBaseSpecifier in view.flags {
        switch basis {
          case 2:  append(dest, "0b")
          case 8:  append(dest, "0o")
          case 10: 
          case 16: append(dest, "0x")
          case: 
        }
    }
    
    show_leading_zero := .LeadingZero in view.flags
    max_integer: u64
    if show_leading_zero {
        for _ in 0..<view.size do max_integer = (max_integer<<8) | 0xFF
    } else {
        max_integer = integer
    }
    
    power :u64= 1
    for power < max_integer {
        power *= basis
        if max_integer / power < basis do break
    }
    
    for ; power > 0; power /= basis {
        div := integer / power
        integer -= div * power
        
        if show_leading_zero || div != 0 || integer == 0 {
            show_leading_zero = true
            append(dest, digits[div])
        }
    }
}

////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////

// @todo(viktor): make boolean and pointer into view_x
format_boolean :: proc(ctx: ^FormatContext, boolean: b32) {
    if ctx.max_depth <= 0 do return
    
    format_view(ctx, view_string(boolean ? "true" : "false"))
}

format_pointer :: proc(ctx: ^FormatContext, data: pmm, target_type: ^runtime.Type_Info = nil) {
    if ctx.max_depth <= 0 do return
    
    if target_type != nil {
        format_view(ctx, view_character('&'))
    }
    
    if target_type == nil || data == nil {
        value := data
        if value == nil {
            format_view(ctx, view_string("nil") )
        } else {
            format_view(ctx, view_integer(cast(umm) value, basis = 16, flags = { .PrependBaseSpecifier, .Uppercase }))
        }
    } else {
        pointed_any := any { data, target_type.id }
        format_any(ctx, pointed_any)
    }
}

format_array :: proc(ctx: ^FormatContext, raw: RawAny, type: ^runtime.Type_Info, count: int) {
    if ctx.max_depth <= 0 do return
    
    format_optional_type(ctx, raw.id)
    
    format_view(ctx, view_character('{'))
    format_multiline_formatting(ctx, .Indent)
    
    defer {
        format_multiline_formatting(ctx, .Outdent)
        format_multiline_formatting(ctx, .Linebreak)
        format_view(ctx, view_character('}'))
    }
    
    for index in 0..< count {
        if index != 0 do format_view(ctx, view_string(", "))
        format_multiline_formatting(ctx, .Linebreak)
        
        offset := cast(umm) (index * type.size)
        
        index_ptr := cast(pmm) (cast(umm) raw.data + offset)
        field := any{ index_ptr, type.id }
        format_any(ctx, field)
    }
}

format_struct :: proc(ctx: ^FormatContext, value: RawAny, variant: runtime.Type_Info_Struct) {
    if ctx.max_depth <= 0 do return
    ctx.max_depth -= 1
    defer ctx.max_depth += 1
        
    format_optional_type(ctx, value.id)
    
    format_view(ctx, view_character('{'))
    format_multiline_formatting(ctx, .Indent)
    
    defer {
        format_multiline_formatting(ctx, .Outdent)
        format_multiline_formatting(ctx, .Linebreak)
        format_view(ctx, view_character('}'))
    }
    
    for index in 0..< variant.field_count {
        if index != 0 do format_view(ctx, view_string(", "))
        format_multiline_formatting(ctx, .Linebreak)
        
        format_view(ctx, view_string(variant.names[index]))
        format_view(ctx, view_string(" = "))
        field_offset := variant.offsets[index]
        field_type   := variant.types[index]
        
        field_ptr := cast(pmm) (cast(umm) value.data + field_offset)
        field := any{field_ptr, field_type.id}
        format_any(ctx, field)
    }
}

format_union :: proc(ctx: ^FormatContext, union_type: typeid, data: pmm, variant: runtime.Type_Info_Union) {
    if ctx.max_depth <= 0 do return
    ctx.max_depth -= 1
    defer ctx.max_depth += 1
    
    tag_ptr := cast(pmm) (cast(umm) data + variant.tag_offset)
    tag : i64 = -1
    switch variant.tag_type.id {
      case u8:   tag = cast(i64) (cast(^u8)  tag_ptr)^
      case i8:   tag = cast(i64) (cast(^i8)  tag_ptr)^
      case u16:  tag = cast(i64) (cast(^u16) tag_ptr)^
      case i16:  tag = cast(i64) (cast(^i16) tag_ptr)^
      case u32:  tag = cast(i64) (cast(^u32) tag_ptr)^
      case i32:  tag = cast(i64) (cast(^i32) tag_ptr)^
      case u64:  tag = cast(i64) (cast(^u64) tag_ptr)^
      case i64:  tag =           (cast(^i64) tag_ptr)^
      case: panic("Invalid union tag type")
    }

    format_optional_type(ctx, union_type)
    
    if data == nil || !variant.no_nil && tag == 0 {
        format_view(ctx, view_string("nil"))
    } else {
        id := variant.variants[variant.no_nil ? tag : (tag-1)].id
        field := any{ data, id }
        format_any(ctx, field)
    }
}

format_matrix :: proc (ctx: ^FormatContext, matrix_type: typeid, data: pmm, type: ^runtime.Type_Info, #any_int column_count, row_count: umm, is_row_major: b32) {
    if ctx.max_depth <= 0 do return
    ctx.max_depth -= 1
    defer ctx.max_depth += 1
    
    format_optional_type(ctx, matrix_type)
    
    format_view(ctx, view_character('{'))
    format_multiline_formatting(ctx, .Indent)
    
    defer {
        format_multiline_formatting(ctx, .Outdent)
        format_multiline_formatting(ctx, .Linebreak)
        format_view(ctx, view_character('}'))
    }
    
    step   := cast(umm) type.size
    stride := step * (is_row_major ? column_count : row_count)
    major  := is_row_major ? row_count : column_count
    minor  := is_row_major ? column_count : row_count
    
    at   := cast(umm) data
    size := stride * major
    end  := at + size
    for _ in 0..<major {
        defer at += stride
        
        format_multiline_formatting(ctx, .Linebreak)
        
        elem_at := at
        for min in 0..<minor {
            defer elem_at += step
            
            if min != 0 do format_view(ctx, view_string(", "))
            format_any(ctx, any{cast(pmm) elem_at, type.id})
        }
        
        format_view(ctx, view_string(", "))
    }
    assert(at == end)
}


format_type :: proc(ctx: ^FormatContext, type_info: ^runtime.Type_Info) {
    if ctx.max_depth <= 0 do return
    ctx.max_depth -= 1
    defer ctx.max_depth += 1
    
    format_endianess :: proc(ctx: ^FormatContext, kind: runtime.Platform_Endianness) {
        switch kind {
          case .Platform: /* nothing */
          case .Little:   format_view(ctx, view_string("le"))
          case .Big:      format_view(ctx, view_string("be"))
        }
    }
    
    if type_info == nil {
        format_view(ctx, view_string("nil"))
    } else {
        switch info in type_info.variant {
          case runtime.Type_Info_Integer:
            if type_info.id == int {
                format_view(ctx, view_string("int"))
            } else if type_info.id == uint {
                format_view(ctx, view_string("uint"))
            } else if type_info.id == uintptr {
                format_view(ctx, view_string("uintptr"))
            } else {
                format_view(ctx, view_character(info.signed ? 'i' : 'u'))
                format_view(ctx, view_integer(type_info.size * 8))
                format_endianess(ctx, info.endianness)
            }
            
          case runtime.Type_Info_Float:
            format_view(ctx, view_character('f'))
            format_view(ctx, view_integer(type_info.size * 8))
            format_endianess(ctx, info.endianness)
            
          case runtime.Type_Info_Complex:
            format_view(ctx, view_string("complex"))
            format_view(ctx, view_integer(type_info.size * 8))
            
          case runtime.Type_Info_Quaternion:
            format_view(ctx, view_string("quaternion"))
            format_view(ctx, view_integer(type_info.size * 8))
            
          case runtime.Type_Info_Procedure:
            format_view(ctx, view_string("proc"))
            // @todo(viktor):  format_view(ctx, view_string(info.convention))
            if info.params == nil do format_view(ctx, view_string("()"))
            else {
                format_view(ctx, view_character('('))
                ps := info.params.variant.(runtime.Type_Info_Parameters)
                for param, i in ps.types {
                    if i != 0 do format_view(ctx, view_string(", "))
                    format_type(ctx, param)
                }
                format_view(ctx, view_character(')'))
            }
            if info.results != nil {
                format_view(ctx, view_string(" -> "))
                format_type(ctx, info.results)
            }
            
          case runtime.Type_Info_Parameters:
            count := len(info.types)
            if       count != 0 do format_view(ctx, view_character('('))
            defer if count != 0 do format_view(ctx, view_character(')'))
            
            for i in 0..<count {
                if i != 0 do format_view(ctx, view_string(", "))
                if i < len(info.names) {
                    format_view(ctx, view_string(info.names[i]))
                    format_view(ctx, view_string(": "))
                }
                format_type(ctx, info.types[i])
            }
            
          case runtime.Type_Info_Boolean:
            if type_info.id == bool {
                format_view(ctx, view_string("bool"))
            } else {
                format_view(ctx, view_character('b'))
                format_view(ctx, view_integer(type_info.size * 8))
            }
              
          case runtime.Type_Info_Named:   format_view(ctx, view_string(info.name))
          case runtime.Type_Info_String:  format_view(ctx, view_string(info.is_cstring ? "cstring" : "string"))
          case runtime.Type_Info_Any:     format_view(ctx, view_string("any"))
          case runtime.Type_Info_Type_Id: format_view(ctx, view_string("typeid"))
          case runtime.Type_Info_Rune:    format_view(ctx, view_string("rune"))
          
          case runtime.Type_Info_Pointer: 
            if info.elem == nil {
                format_view(ctx, view_string("rawptr"))
            } else {
                format_view(ctx, view_character('^'))
                format_type(ctx, info.elem)
            }
            
          case runtime.Type_Info_Multi_Pointer:
            format_view(ctx, view_string("[^]"))
            format_type(ctx, info.elem)
            
          case runtime.Type_Info_Soa_Pointer:
            format_view(ctx, view_string("#soa ^"))
            format_type(ctx, info.elem)
            
            
          case runtime.Type_Info_Simd_Vector:
            format_view(ctx, view_string("#simd["))
            format_view(ctx, view_integer(info.count))
            format_view(ctx, view_character(']'))
            format_type(ctx, info.elem)
            
          case runtime.Type_Info_Matrix:
            if info.layout == .Row_Major do format_view(ctx, view_string("#row_major "))
            format_view(ctx, view_string("matrix["))
            format_view(ctx, view_integer(info.row_count))
            format_view(ctx, view_character(','))
            format_view(ctx, view_integer(info.column_count))
            format_view(ctx, view_character(']'))
            format_type(ctx, info.elem)
                
          case runtime.Type_Info_Array:
            format_view(ctx, view_character('['))
            format_view(ctx, view_integer(info.count))
            format_view(ctx, view_character(']'))
            format_type(ctx, info.elem)
            
          case runtime.Type_Info_Enumerated_Array:
            if info.is_sparse do format_view(ctx, view_string("#sparse "))
            format_view(ctx, view_character('['))
            format_type(ctx, info.index)
            format_view(ctx, view_character(']'))
            format_type(ctx, info.elem)
            
          case runtime.Type_Info_Dynamic_Array:
            format_view(ctx, view_string("[dynamic]"))
            format_type(ctx, info.elem)
            
          case runtime.Type_Info_Slice:
            format_view(ctx, view_string("[]"))
            format_type(ctx, info.elem)
            
          case runtime.Type_Info_Struct:
            switch info.soa_kind {
              case .None:
              case .Fixed:
                format_view(ctx, view_string("#soa["))
                format_view(ctx, view_integer(info.soa_len))
                format_view(ctx, view_character(']'))
                format_type(ctx, info.soa_base_type)
              case .Slice:
                format_view(ctx, view_string("#soa[]"))
                format_type(ctx, info.soa_base_type)
              case .Dynamic:
                format_view(ctx, view_string("#soa[dynamic]"))
                format_type(ctx, info.soa_base_type)
            }
            
            format_view(ctx, view_string("struct "))
            if .packed    in info.flags  do format_view(ctx, view_string("#packed "))
            if .raw_union in info.flags  do format_view(ctx, view_string("#raw_union "))
            if .no_copy   in info.flags  do format_view(ctx, view_string("#no_copy "))
            if .align     in info.flags {
                format_view(ctx, view_string("#align("))
                format_view(ctx, view_integer(type_info.align))
                format_view(ctx, view_character(')'))
            }
            
            format_view(ctx, view_character('{'))
            format_multiline_formatting(ctx, .Indent)
            defer {
                format_multiline_formatting(ctx, .Outdent)
                format_multiline_formatting(ctx, .Linebreak)
                format_view(ctx, view_character('}'))
            }
            
            for i in 0..<info.field_count {
                if i != 0 do format_view(ctx, view_string(", "))
                format_multiline_formatting(ctx, .Linebreak)
                
                if info.usings[i] do format_view(ctx, view_string("using "))
                format_view(ctx, view_string(info.names[i]))
                format_view(ctx, view_string(": "))
                format_type(ctx, info.types[i])
            }
            
          case runtime.Type_Info_Union:
            format_view(ctx, view_string("union "))
            if info.no_nil      do format_view(ctx, view_string("#no_nil "))
            if info.shared_nil  do format_view(ctx, view_string("#shared_nil "))
            if info.custom_align {
                format_view(ctx, view_string("#align("))
                format_view(ctx, view_integer(type_info.align))
                format_view(ctx, view_character(')'))
            }
            
            format_view(ctx, view_character('{'))
            format_multiline_formatting(ctx, .Indent)
            defer {
                format_multiline_formatting(ctx, .Outdent)
                format_multiline_formatting(ctx, .Linebreak)
                format_view(ctx, view_character('}'))
            }
            
            for variant, i in info.variants {
                if i != 0 do format_view(ctx, view_string(", "))
                format_multiline_formatting(ctx, .Linebreak)
            
                format_type(ctx, variant)
            }
            
          case runtime.Type_Info_Enum:
            format_view(ctx, view_string("enum "))
            format_type(ctx, info.base)
            
            format_view(ctx, view_character('{'))
            format_multiline_formatting(ctx, .Indent)
            defer {
                format_multiline_formatting(ctx, .Outdent)
                format_multiline_formatting(ctx, .Linebreak)
                format_view(ctx, view_character('}'))
            }
            
            for name, i in info.names {
                if i != 0 do format_view(ctx, view_string(", "))
                format_multiline_formatting(ctx, .Linebreak)

                format_view(ctx, view_string(name))
            }
            
          case runtime.Type_Info_Map:
            format_view(ctx, view_string("map["))
            format_type(ctx, info.key)
            format_view(ctx, view_character(']'))
            format_type(ctx, info.value)
            
          case runtime.Type_Info_Bit_Set:
            is_type :: proc(info: ^runtime.Type_Info, $T: typeid) -> bool {
                if info == nil { return false }
                _, ok := runtime.type_info_base(info).variant.(T)
                return ok
            }
            
            format_view(ctx, view_string("bit_set["))
            switch {
              case is_type(info.elem, runtime.Type_Info_Enum):
                format_type(ctx, info.elem)
              case is_type(info.elem, runtime.Type_Info_Rune):
                // @todo(viktor): unicode
                // io.write_encoded_rune(w, rune(info.lower), true, &n) or_return
                format_view(ctx, view_string("..="))
                unimplemented("support unicode encoding/decoding")
                // io.write_encoded_rune(w, rune(info.upper), true, &n) or_return
              case:
                format_view(ctx, view_integer(info.lower))
                format_view(ctx, view_string("..="))
                format_view(ctx, view_integer(info.upper))
            }
            
            if info.underlying != nil {
                format_view(ctx, view_string("; "))
                format_type(ctx, info.underlying)
            }
            format_view(ctx, view_character(']'))
            
          case runtime.Type_Info_Bit_Field:
            format_view(ctx, view_string("bit_field "))
            format_type(ctx, info.backing_type)
            
            format_view(ctx, view_character('{'))
            format_multiline_formatting(ctx, .Indent)
            defer {
                format_multiline_formatting(ctx, .Outdent)
                format_multiline_formatting(ctx, .Linebreak)
                format_view(ctx, view_character('}'))
            }
         
            for i in 0..<info.field_count {
                if i != 0 do format_view(ctx, view_string(", "))
                format_multiline_formatting(ctx, .Linebreak)
                
                format_view(ctx, view_string(info.names[i]))
                format_view(ctx, view_character(':'))
                format_type(ctx, info.types[i])
                format_view(ctx, view_character('|'))
                format_view(ctx, view_integer(info.bit_sizes[i]))
            }
        }
    }
}

////////////////////////////////////////////////

@(private="file") 
RawSlice :: struct {
    data: rawptr,
    len:  int,
}
@(private="file") 
RawAny :: struct {
    data: rawptr,
	id:   typeid,
}